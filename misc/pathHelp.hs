{-# LANGUAGE PackageImports #-}
import "SVGPath" Graphics.SVG.ReadPath
import "polyparse" Text.ParserCombinators.Poly.Plain
import "polyparse" Text.Parse
import Text.Printf
import Data.List

{- utilities for simplifying SVG image of state diagram generated by graphviz -}

-- fix Path
fixPath :: String -> IO ()
fixPath str = pathFromString str >>= putStrLn . pathToStr . map (translateCommand 4 499)

translateCommand :: Double -> Double -> PathCommand -> PathCommand
translateCommand dx dy piece = case piece of
    M_abs (x,y) -> M_abs (fixX x, fixY y)
    C_abs (x1,y1,x2,y2,x3,y3) -> C_abs (fixX x1, fixY y1
                                       ,fixX x2, fixY y2
                                       ,fixX x3, fixY y3)
  where
    fixX = fromIntegral . adjustCoord dx
    fixY = fromIntegral . adjustCoord dy

adjustCoord delta coord = round $ coord + delta

pathToStr :: [PathCommand] -> String
pathToStr = unwords . map pieceToStr

pieceToStr :: PathCommand -> String
pieceToStr piece = case piece of
    M_abs (x,y) -> 'M' : printf "%.0f,%.0f" x y
    C_abs (x1,y1,x2,y2,x3,y3) -> 'C' : printf "%.0f,%.0f %.0f,%.0f %.0f,%.0f" x1 y1 x2 y2 x3 y3

-- fix Points

fixPoints :: String -> Either String String
fixPoints str =  unwords . map (printPoint . fixPoint) <$> fst (runParser pointsParser str)

printPoint :: (Int, Int) -> String
printPoint = uncurry (printf "%d,%d")

fixPoint :: (Double, Double) -> (Int, Int)
fixPoint (x,y) = (adjustCoord 4 x, adjustCoord 499 y)

pointsParser :: Parser Char [(Double, Double)]
pointsParser = pairOf signedFloat `sepBy` literal " "
  where
    pairOf p = (,) <$> (p <* literal ",") <*> p
    signedFloat = parseSigned parseFloat
